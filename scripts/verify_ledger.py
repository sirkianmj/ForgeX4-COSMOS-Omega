#
# ForgeX4 COSMOS-Î©
#
# Author: Kian Mansouri Jamshidi
# Project Director: Kian Mansouri Jamshidi
#
# File: scripts/verify_ledger.py
# Date: 2025-09-28
#
# Description:
# This script is the final artifact for Sprint 7, Task 7.2. It serves as an
# independent auditor for any ledger file generated by the foundry. It reads
# a ledger, recalculates the cryptographic hash chain from the genesis hash
# to the final event, and verifies that the chain is unbroken and the log
# has not been tampered with.
#

import json
import hashlib
import sys
import os

def calculate_event_hash(event_data: dict) -> str:
    """
    Calculates the SHA-256 hash for a given event dictionary.
    
    To ensure deterministic hashes, this function removes the existing 'event_hash'
    key before serialization and sorts the keys.
    """
    # Create a copy to avoid modifying the original dictionary in memory
    event_copy = event_data.copy()
    
    # The stored hash must be removed before recalculating, otherwise the hash
    # would be calculated on its own content, which is impossible to verify.
    if 'event_hash' in event_copy:
        del event_copy['event_hash']
        
    event_string = json.dumps(event_copy, sort_keys=True).encode('utf-8')
    return hashlib.sha256(event_string).hexdigest()

def verify_ledger_integrity(ledger_path: str) -> bool:
    """
    Verifies the cryptographic chain of a ledger file.

    Args:
        ledger_path (str): The path to the ledger JSON file.

    Returns:
        bool: True if the ledger is valid, False otherwise.
    """
    print(f"\n--- Verifying Ledger: {os.path.basename(ledger_path)} ---")
    
    try:
        with open(ledger_path, 'r') as f:
            events = json.load(f)
    except FileNotFoundError:
        print(f"  [FAIL] Error: Ledger file not found at '{ledger_path}'")
        return False
    except json.JSONDecodeError:
        print(f"  [FAIL] Error: Could not decode JSON from file '{ledger_path}'. It may be corrupted.")
        return False

    if not events:
        print("  [WARN] Ledger file is empty. Integrity check cannot be performed.")
        return True # An empty file isn't technically invalid

    # Initialize with the known genesis hash for the start of the chain
    last_known_hash = '0' * 64
    
    for i, event in enumerate(events):
        print(f"  Verifying Event {i}... ", end="")
        
        # 1. Check if the event correctly links to the previous one
        if event.get('previous_event_hash') != last_known_hash:
            print(f"[FAIL]")
            print(f"  - CHAIN BROKEN at Event {i}:")
            print(f"    - Expected previous_hash: {last_known_hash}")
            print(f"    - Found previous_hash:    {event.get('previous_event_hash')}")
            return False
            
        # 2. Recalculate the event's hash based on its content
        recalculated_hash = calculate_event_hash(event)
        
        # 3. Check if the recalculated hash matches the one stored in the file
        if recalculated_hash != event.get('event_hash'):
            print(f"[FAIL]")
            print(f"  - HASH MISMATCH at Event {i}:")
            print(f"    - Recalculated hash: {recalculated_hash}")
            print(f"    - Stored hash:       {event.get('event_hash')}")
            return False
            
        # If both checks pass, update the last_known_hash for the next iteration
        last_known_hash = event.get('event_hash')
        print(f"[OK]")

    print("\n--- Verification Result ---")
    print("  [SUCCESS] Ledger integrity confirmed. The hash chain is valid.")
    return True


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/verify_ledger.py <path_to_ledger_file.json>")
        sys.exit(1)
        
    target_ledger = sys.argv[1]
    verify_ledger_integrity(target_ledger)